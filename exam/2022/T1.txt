## T1.c

+ 主进程创建 2 个子进程

+ 主进程创建 1 个管道
  - 只调用一次 pipe
  - 管道被 2 个子进程继承

+ 主进程作为生产者  
  - 生产 8 个字符: 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h'
  - 将字符写入到管道
  - 最后，生产 2 个字符 'z'，作为结束标记

+ 子进程作为消费者 
  - 从管道中读取字符，使用 toupper(c) 将字符转换为大写
  - 当读入到字符 'z' 时，子进程退出

+ 要求按如下格式输出
  - 创建了两个子进程，pid 分别是 4597 和 4598
  - 使用 getpid() 获取当前进程的 pid
  - 主进程最后输出 Produce END

```
4598: A
4597: B
4598: C
4598: D
4597: E
4598: F
4598: G
4597: H
4597: I
4598: J
Produce END
```

+ 函数 getpid() 的用法

```
pid_t pid = getpid();
printf("%x\n", pid);
```

+ 注意
  - 主进程只需要调用一次 pipe()
  - 这 3 个进程是并发执行的
  - 为了达到交织输出的效果
    * 生产者写一次数据后，调用 delay() 
    * 消费者读一次数据后，调用 delay() 
    * delay() 延时一段时间，已经帮你写好
